["It has been a long day." #delay/ms 1000
 "The last thing you remember is falling asleep" #delay/ms 1000
 "...at the REPL." #delay/ms 2000
 nil "When you open your eyes, just like they said, you feel great enlightenment." #delay/ms 3000
 nil "You see the beauty, the purity, the simplicity of Lisp unfold before you." #delay/ms 3000

 nil "You recall the number 1" #delay/ms 1000
 [:div {:class "number"} 1] #delay/ms 2000
 "and how it is also an expression, evaluating to itself." #delay/ms 2000 nil
 "Try evaluating it, by pressing the button or the enter key."
 #game/expression {:expression 1, :target #{1}}
 "Nothing happened. As expected." #delay/ms 1000
 "All is well." #delay/ms 1000
 nil "Numbers, strings, nil, they all evaluate to themselves." #delay/ms 1000
 "Pure." #delay/ms 1000
 "Simple." #delay/ms 1000
 "Beautiful." #delay/ms 1000
 #game/expression {:expression (continue), :target #{(continue)}}

 nil "But, of course, if everything evaluates to itself, what point is there to evaluating at all?" #delay/ms 2000
 nil "Symbols, you think, do not evaluate to themselves, but to the value they name." #delay/ms 2000
 nil "This is a symbol, try evaluating it too:"
 #game/expression {:expression pi, :target #{3.14}}
 "Pi..." #delay/ms 1000
 "Pi." #delay/ms 1000
 "In your excitement you remember only the first few digits." #delay/ms 1000
 "It doesn't matter. It's enough for most things." #delay/ms 1000
 #game/expression {:expression (continue), :target #{(continue)}}

 nil "Lists, too, evaluate to something different to themselves." #delay/ms 1000
 nil "Try evaluating this as well."
 #game/expression {:expression (+ 1 2), :target #{3}}
 "You breathe in." #delay/ms 2000
 "(+ 1 2)" #delay/ms 2000
 "\"Add 1 and 2\"" #delay/ms 2000
 "A function, followed by its arguments." #delay/ms 2000
 nil "Adding 1 and 2 results in 3. Could there be a better notation for such a thing?" #delay/ms 3000
 nil "Infix notations only lead to disputes over which operation gets to apply first." #delay/ms 3000
 nil "It's now your turn to laugh, at those who laughed at your many parentheses and prefix notation." #delay/ms 3000
 nil "They really have no idea."
 nil
 #game/expression {:expression (continue), :target #{(continue)}}

 nil "Lists can, of course, contain other lists." #delay/ms 2000
 nil "Normally sub-expressions may get evaluated first." #delay/ms 2000
 nil "But not here." #delay/ms 2000
 nil "Not now." #delay/ms 2000
 nil "You are in control." #delay/ms 2000
 nil "The evaluation order?" #delay/ms 2000
 nil "You choose." #delay/ms 2000
 nil "Navigate to inner expressions with the arrow keys or buttons."
 nil "There's an undo button if you make a mistake."
 #game/expression {:expression (+ 1 2 (* 3 4)), :target #{15}}

 #_[
    nil
    "The if function can be used to select a value based on a condition."
    "Try these examples:"
    #game/expression {:expression (if true then else), :target #{then}}
    #game/expression {:expression (if false then else), :target #{else}}
    "With no else expression, it's taken to be nil."
    #game/expression {:expression (if false then), :target #{nil}}
    nil
    "Then there is =, the comparison function."
    #game/expression {:expression ((= 1 0) (= 0 0)), :target #{(false true)}}
    "Different types cannot compare equal:"
    #game/expression {:expression ((= a 0) (= b (1 2 3))), :target #{(false false)}}
    nil
    "Now see if you can use this to compute The Answer to the Ultimate Question of Life, the Universe, and Everything: 42."
    #game/expression {:expression
                      (if (= answer answer) (* 6 9) (* 7 6))
                      :target #{42}}
    nil
    "Cons is another function, it prepends a value to a list:"
    #game/expression {:expression (cons + (1 2 3)), :target #{6}}
    nil
    "First can be used to get the first element of a list:"
    #game/expression {:expression ((first (+ 1 2)) 3 4), :target #{7}}
    nil
    "Next can be used to get a list of all but the first element of a list:"
    #game/expression {:expression (cons * (next (+ 1 2))), :target #{2}}
    nil
    "List just creates a list from its arguments:"
    #game/expression {:expression (list + 1 2 3), :target #{6}}
    nil
    "A fn expression creates a function, which can be applied to arguments."
    "There is no need to evaluate the fn expression, just use it as a function directly."
    "The first argument is the argument list, the next is the function body."
    #game/expression {:expression ((fn (x) (* x x)) 5), :target #{25}}
    "Applying it to 5 substitutes the value in for x."
    nil
    "Here's another example, try to evaluate this to pi:"
    #game/expression {:expression ((fn (pi) (- pi pi)) 0), :target #{3.14}}

    nil
    "That's all for now. More coming soon!"]]
